#include "Funciones_coordinador.h"


////////////////////////////////////////////////// PROCESAMIENTO ///////////////////////////////////////////////////

int procesar_mensaje(int socket){
	int resultado, id;
	char* clave;
	nodo* nodo_instancia;
	nodo* el_nodo;
	int protocolo_extra = 1; //Sacar inicializacion
	t_esi_operacion instruccion;
	status_clave status;
	void* buffer_int = malloc(sizeof(int));
	/*recibir(socket, buffer_int, sizeof(int), logger);
	id = deserializar_id(buffer_int);*/
	id = recibir_int(socket, logger);
	log_info(logger, "Protocolo recibido: %d", id);
	int rta_esi;

	switch(id){
		case 20:
			return 1;

		case 21:
			clave = recibir_pedido_clave(socket);
			nodo_instancia = buscar_instancia(clave);
			protocolo_extra = 1;
			resultado = enviar_pedido_valor(nodo_instancia->socket, clave, protocolo_extra);
			return resultado;
			break;

		case 23:
			resultado = desconectar_instancia(socket);
			return 1;
			break;

		case 24:
			serializar_id(buffer_int, 64);
			resultado = enviar(esi_ejecutando->socket, buffer_int, sizeof(int), logger);
			return resultado;
			break;

		case 25: //Exito instancia
			log_info(logger, "Recibi confirmacion de la Instancia %d", instancia_seleccionada->id);
			pthread_mutex_unlock(&m_instancia_seleccionada);
			rta_esi = 84;
			serializar_id(buffer_int, rta_esi);
<<<<<<< HEAD
			resultado = enviar(esi_ejecutando->socket, buffer_int, sizeof(int), logger);
			log_info(logger, "Le digo al ESI %d que la ejecucion fue exitosa", esi_ejecutando->id);
			pthread_mutex_unlock(&m_esi_ejecutando);
=======
			log_info(logger, "Le voy a responder: %d al esi", rta_esi);
			resultado = enviar(esi_ejecutando->socket, buffer_int, sizeof(int), logger);
			log_info(logger, "Respondi al ESI");
>>>>>>> 8cc307fcb7b2a95186c9e992016ce3d272d9411f
			return resultado;
			break;

		case 81: //Fin de ejecucion del ESI
			el_nodo = encontrar_esi(socket);
			pthread_mutex_lock(&m_hilo_a_cerrar);
			hilo_a_cerrar = &el_nodo->hilo;
			pthread_mutex_lock(&m_socket_esi_buscado);
			socket_esi_buscado = el_nodo->socket;
			log_info(logger, "Voy a eliminar");
			pthread_mutex_lock(&m_lista_esis);
			list_remove_by_condition(lista_esis, condicion_socket_esi);
			pthread_mutex_unlock(&m_lista_esis);
			pthread_mutex_unlock(&m_socket_esi_buscado);
			sem_post(&s_cerrar_hilo);
			return -1;
			break;

		case 82: //Instruccion
			instruccion = recibir_instruccion(socket);
			procesar_instruccion(instruccion, socket);
			return 1;
			break;

		case 83: //Status clave
			status = recibir_status(socket);
			resultado = enviar_status_clave(socket_planificador, status);
			return resultado;
			break;

		case 84: //Exito Planificador
			log_info(logger, "Recibi confirmacion del Planificador");
			enviar_operacion(instancia_seleccionada->socket, operacion_ejecutando);
			pthread_mutex_unlock(&m_operacion_ejecutando);
			log_info(logger, "Envie la instruccion a la instancia %d", instancia_seleccionada->id);
			return 1;

		case 85: //Fallo
			//Falta implementar, minimizar uso
			return -1;
			break;

		case 87: //Fallo clave no identificada
			log_info(logger, "Fallo por clave no identificada, ID ESI: %d", esi_ejecutando->id);
			rta_esi = 87;
			serializar_id(buffer_int, rta_esi);
			resultado = enviar(esi_ejecutando->socket, buffer_int, sizeof(int), logger);
			pthread_mutex_lock(&m_hilo_a_cerrar);
			hilo_a_cerrar = &esi_ejecutando->hilo;
			sem_post(&s_cerrar_hilo);
			pthread_mutex_unlock(&m_instancia_seleccionada);
			pthread_mutex_unlock(&m_esi_ejecutando);
			return resultado;
			break;

		case 88://Fallo clave inaccesible
			log_info(logger, "Fallo por clave inaccesible, ID ESI: %d", esi_ejecutando->id);
			rta_esi = 88;
			serializar_id(buffer_int, rta_esi);
			resultado = enviar(esi_ejecutando->socket, buffer_int, sizeof(int), logger);
			pthread_mutex_lock(&m_hilo_a_cerrar);
			hilo_a_cerrar = &esi_ejecutando->hilo;
			sem_post(&s_cerrar_hilo);
			pthread_mutex_unlock(&m_instancia_seleccionada);
			pthread_mutex_unlock(&m_esi_ejecutando);
			return resultado;
			break;

		case 89://Fallo clave no bloqueada
			log_info(logger, "Fallo por clave no bloqueada, ID ESI: %d", esi_ejecutando->id);
			rta_esi = 89;
			serializar_id(buffer_int, rta_esi);
			resultado = enviar(esi_ejecutando->socket, buffer_int, sizeof(int), logger);
			pthread_mutex_lock(&m_hilo_a_cerrar);
			hilo_a_cerrar = &esi_ejecutando->hilo;
			sem_post(&s_cerrar_hilo);
			pthread_mutex_unlock(&m_instancia_seleccionada);
			pthread_mutex_unlock(&m_esi_ejecutando);
			return resultado;

		case 90://Hay que bloquear al ESI
			log_info(logger, "Le digo al ESI %d que esta bloqueado", esi_ejecutando->id);
			rta_esi = 90;
			serializar_id(buffer_int, rta_esi);
			resultado = enviar(esi_ejecutando->socket, buffer_int, sizeof(int), logger);
			pthread_mutex_lock(&m_hilo_a_cerrar);
			hilo_a_cerrar = &esi_ejecutando->hilo;
			pthread_mutex_unlock(&m_instancia_seleccionada);
			pthread_mutex_unlock(&m_esi_ejecutando);
			return resultado;

		default:
			return -1;
			break;
	}
}

int procesar_instruccion(t_esi_operacion instruccion, int socket){
	char* clave;
	switch(instruccion.keyword){
	case GET:
		clave = malloc(sizeof(instruccion.argumentos.GET.clave));
		memcpy(clave, instruccion.argumentos.GET.clave, strlen(instruccion.argumentos.GET.clave)+1);
		break;
	case SET:
		clave = malloc(sizeof(instruccion.argumentos.SET.clave));
		memcpy(clave, instruccion.argumentos.SET.clave, strlen(instruccion.argumentos.SET.clave)+1);
		break;
	case STORE:
		clave = malloc(sizeof(instruccion.argumentos.STORE.clave));
		memcpy(clave, instruccion.argumentos.STORE.clave, strlen(instruccion.argumentos.STORE.clave)+1);
		break;
	}
	pthread_mutex_lock(&m_esi_ejecutando);
	pthread_mutex_lock(&m_instancia_seleccionada);
	esi_ejecutando = encontrar_esi(socket);
	log_info(logger, "Id esi: %d", esi_ejecutando->id);
	instancia_seleccionada = buscar_instancia(clave);
	log_info(logger, "Id instancia: %d", instancia_seleccionada->id);
	pthread_mutex_lock(&m_operacion_ejecutando);
	operacion_ejecutando = instruccion;

	enviar_operacion(socket_planificador, instruccion);
	return 1;
}

//////////////////////////////////////////////////// CONEXION /////////////////////////////////////////////////////

int handshake(int socket_cliente){
	int conexion_hecha = 0;

	t_handshake proceso_recibido;
	t_handshake yo = {0, COORDINADOR};
	void* buffer_recepcion = malloc(sizeof(int)*2);
	void* buffer_envio = malloc(sizeof(int)*3);

	recibir(socket_cliente, buffer_recepcion, sizeof(int)*2, logger);
	proceso_recibido = deserializar_handshake(buffer_recepcion);

	log_info(logger, "Proceso recibido %d", proceso_recibido.proceso);
	log_info(logger, "Id proceso recibido %d", proceso_recibido.id);

	free(buffer_recepcion);

	serializar_handshake(buffer_envio, yo);
	enviar(socket_cliente, buffer_envio, sizeof(int)*3, logger);

	free(buffer_envio);

	switch(proceso_recibido.proceso){
	case PLANIFICADOR:
		if(!conexion_hecha){
			conexion_hecha = 1;
			return 1;
		}else{
			return -1;
		}
		break;

	case INSTANCIA:
		log_info(logger, "Se establecio la conexion con una Instancia ");
		agregar_nueva_instancia(socket_cliente, proceso_recibido.id);
		return 1;
		break;

	case ESI:
		log_info(logger, "Se establecio la conexion con un ESI ");
		agregar_nuevo_esi(socket_cliente, proceso_recibido.id);
		return 1;
		break;

		default:
		return -1;
		break;
	}
}

void procesar_conexion(){
	int id_mensaje;
	while(1){
		int socket_cliente = aceptar_conexion(socket_escucha);
		recibir(socket_cliente, &id_mensaje, sizeof(int), logger);
		if(id_mensaje == 80){
			handshake(socket_cliente);
		}
	}
}

void atender_planificador(){
	log_info(logger, "Entre en el hilo del planificador");
	while(1){
		procesar_mensaje(socket_planificador);
	}
}

void atender_esi(void* datos_esi){
	int resultado = 1;
	log_info(logger, "Estoy en el hilo del esi!");
	hilo_proceso mis_datos = deserializar_hilo_proceso(datos_esi);
	while(resultado > 0){
		resultado = procesar_mensaje(mis_datos.socket);
	}
}

void atender_instancia(void* datos_instancia){
	log_info(logger, "Estoy en el hilo de la instancia!");
	hilo_proceso mis_datos = deserializar_hilo_proceso(datos_instancia);
	while(1){
		procesar_mensaje(mis_datos.socket);
	}
}

int desconectar_instancia(int socket){
	pthread_mutex_lock(&m_socket_instancia_buscado);
	socket_instancia_buscado = socket;
	pthread_mutex_lock(&m_lista_instancias);
	pthread_mutex_lock(&m_lista_instancias);
	nodo* el_nodo = list_find(lista_instancias, condicion_socket_instancia);
	pthread_mutex_unlock(&m_lista_instancias);
	pthread_mutex_unlock(&m_lista_instancias);
	pthread_mutex_unlock(&m_socket_instancia_buscado);
	int resultado = pthread_join(el_nodo->hilo, NULL);
	log_info(logger, "ya tire el join: %d", resultado);
	return resultado;
}

/////////////////////////////////////////////// FUNCIONES DE LISTAS ///////////////////////////////////////////////

bool condicion_socket_esi(void* datos){
	nodo un_nodo = *((nodo*) datos);
	return un_nodo.socket == socket_esi_buscado;
}

bool condicion_socket_instancia(void* datos){
	nodo un_nodo = *((nodo*) datos);
	return un_nodo.socket == socket_instancia_buscado;
}

void reemplazar_instancia(nodo un_nodo){
	list_remove_by_condition(lista_instancias, condicion_socket_instancia);
	list_add(lista_instancias, &un_nodo);
}

nodo* buscar_instancia(char* clave){
	nodo* nodo_instancia;
	pthread_mutex_lock(&m_diccionario_claves);
	if(dictionary_has_key(diccionario_claves, clave)){
		nodo_instancia = dictionary_get(diccionario_claves, clave);
	} else {
		nodo_instancia = seleccionar_instancia(clave);
		//agregar clave al diccionario
	}
	pthread_mutex_unlock(&m_diccionario_claves);
	return nodo_instancia;
}

nodo* seleccionar_instancia(char* clave){
	nodo* instancia_seleccionada;
	switch(info_coordinador.algoritmo_distribucion){
	case EL:
		pthread_mutex_lock(&m_lista_instancias);
		log_info(logger, "Tamanio: %d", list_size(lista_instancias));
		pthread_mutex_lock(&m_ultima_instancia_EL);
		//instancia_seleccionada = list_get(lista_instancias, ultima_instancia_EL);
		instancia_seleccionada = list_get(lista_instancias, 0);
		if(ultima_instancia_EL++ == list_size(lista_instancias)){ultima_instancia_EL = 0;}
		pthread_mutex_unlock(&m_ultima_instancia_EL);
		pthread_mutex_unlock(&m_lista_instancias);
		break;
	case LSU:
		break;
	case KE:
		break;
	}
	return instancia_seleccionada;
}

nodo* encontrar_esi(int socket){//verificar semaforos
	pthread_mutex_lock(&m_socket_esi_buscado);
	socket_esi_buscado = socket;
	pthread_mutex_lock(&m_lista_esis);
	nodo* el_nodo = list_find(lista_esis, condicion_socket_esi);
	pthread_mutex_unlock(&m_lista_esis);
	pthread_mutex_unlock(&m_socket_esi_buscado);
	log_info(logger, "Socket encontrado: %d, y su id: %d", el_nodo->socket, el_nodo->id);
	return el_nodo;
}

/////////////////////////////////////////////// FUNCIONES DE HILOS ////////////////////////////////////////////////

void serializar_hilo_proceso(void* buffer, hilo_proceso hilo){
	hilo_proceso* info_hilo_proceso = malloc(sizeof(hilo_proceso));
	*info_hilo_proceso = hilo;
	memcpy(buffer, info_hilo_proceso, sizeof(hilo_proceso));
	free(info_hilo_proceso);
}

hilo_proceso deserializar_hilo_proceso(void *buffer_recepcion){
	hilo_proceso hilo_proceso_recibido;
	memcpy(&hilo_proceso_recibido.socket, buffer_recepcion, sizeof(int));
	memcpy(&hilo_proceso_recibido.id, buffer_recepcion + sizeof(int), sizeof(int));
	return hilo_proceso_recibido;
}

void agregar_nuevo_esi(int socket_esi, int id_esi){
	hilo_proceso datos_esi = {socket_esi, id_esi};
	void* buffer = malloc(sizeof(int)*2);
	serializar_hilo_proceso(buffer, datos_esi);
	pthread_t hilo_esi;
	pthread_create(&hilo_esi, 0, atender_esi, buffer); //(void*) &
	nodo* el_nodo = malloc(sizeof(nodo));
	el_nodo->socket = socket_esi;
	el_nodo->id = id_esi;
	el_nodo->hilo = hilo_esi;
	pthread_mutex_lock(&m_lista_esis);
	list_add(lista_esis, el_nodo);
	pthread_mutex_unlock(&m_lista_esis);
}

void agregar_nueva_instancia(int socket_instancia, int id_instancia){
	hilo_proceso datos_instancia = {socket_instancia, id_instancia};
	void* buffer = malloc(sizeof(int)*2);
	serializar_hilo_proceso(buffer, datos_instancia);
	pthread_t hilo_instancia;
	pthread_create(&hilo_instancia, 0, atender_instancia, buffer);
	nodo* el_nodo = malloc(sizeof(nodo));
	el_nodo->socket = socket_instancia;
	el_nodo->id = id_instancia;
	el_nodo->hilo = hilo_instancia;
	pthread_mutex_lock(&m_lista_instancias);
	list_add(lista_instancias, el_nodo);
	pthread_mutex_unlock(&m_lista_instancias);
	/*socket_instancia_buscado = nodo.socket;
	bool precencia_instancia = verificar_existencia_instancia(nodo);
	if(!precencia_instancia){
		list_add(lista_instancias, &nodo);
	}else{
		reemplazar_instancia(nodo);
	}*/
}

///////////////////////////////////////////////// INICIALIZACION /////////////////////////////////////////////////

void leer_archivo_configuracion(){
	//Supongo que en el archivo el orden es: ip, puerto, algoritmo, entradas, tamaÃ±o y retardo
	FILE* archivo = fopen("Configuracion_coordinador.txt", "r");

	fscanf(archivo, "%s %d %d %d %d %d",
			info_coordinador.ip,
			&(info_coordinador.puerto_escucha),
			&(info_coordinador.algoritmo_distribucion),
			&(info_coordinador.cantidad_entradas),
			&(info_coordinador.tamano_entrada),
			&(info_coordinador.retardo));
	fclose(archivo);
}

void inicializar_coordinador(){
	socket_escucha = inicializar_servidor(info_coordinador.puerto_escucha, logger);
	lista_esis = list_create();
	lista_instancias = list_create();
	diccionario_claves = dictionary_create();
	ultima_instancia_EL = 0;
	inicializar_semaforos();
}

void inicializar_semaforos(){
	if (pthread_mutex_init(&m_operacion_ejecutando, NULL) != 0) {printf("Fallo al inicializar mutex\n");}
	if (pthread_mutex_init(&m_esi_ejecutando, NULL) != 0) {printf("Fallo al inicializar mutex\n");}
	if (pthread_mutex_init(&m_instancia_seleccionada, NULL) != 0) {printf("Fallo al inicializar mutex\n");}
	if (pthread_mutex_init(&m_hilo_a_cerrar, NULL) != 0) {printf("Fallo al inicializar mutex\n");}
	if (pthread_mutex_init(&m_ultima_instancia_EL, NULL) != 0) {printf("Fallo al inicializar mutex\n");}
	if (pthread_mutex_init(&m_diccionario_claves, NULL) != 0) {printf("Fallo al inicializar mutex\n");}
	if (pthread_mutex_init(&m_socket_instancia_buscado, NULL) != 0) {printf("Fallo al inicializar mutex\n");}
	if (pthread_mutex_init(&m_socket_esi_buscado, NULL) != 0) {printf("Fallo al inicializar mutex\n");}
	if (pthread_mutex_init(&m_lista_instancias, NULL) != 0) {printf("Fallo al inicializar mutex\n");}
	if (pthread_mutex_init(&m_lista_esis, NULL) != 0) {printf("Fallo al inicializar mutex\n");}
	sem_init(&s_cerrar_hilo, 0, 0); //El primer 0 es para compartir solamente con mis hilos y el segundo es el valor
}

void conectar_planificador(){
	int socket_cliente = aceptar_conexion(socket_escucha);
	int protocolo;

	recibir(socket_cliente, &protocolo, sizeof(int), logger);
	if(protocolo == 80){
		int resultado = handshake(socket_cliente);
		if(resultado >= 0){
			socket_planificador = socket_cliente;
			log_info(logger, "Se establecio la conexion con el Planificdor");
		} else{
			log_info(logger, "Fallo en la conexion con el Planificdor");
		}
	} else{
		log_info(logger, "Fallo en la conexion con el Planificdor");
	}
}

///////////////////////////////////////////////// COMUNICACION /////////////////////////////////////////////////

int enviar_configuracion_instancia(int socket){
	datos_configuracion mensaje = {info_coordinador.tamano_entrada, info_coordinador.cantidad_entradas};
	void* buffer = malloc(sizeof(int)*3);
	serializar_configuracion_inicial_instancia(buffer, mensaje);
	int bytes_enviados = enviar(socket, buffer, sizeof(int)*3, logger);
	return bytes_enviados;
}

int enviar_status_clave(int socket, status_clave status){
	int tamanio = tamanio_buffer_status(status);
	void* buffer = malloc(tamanio);
	serializar_status_clave(buffer, status);
	int bytes_enviados = enviar(socket, buffer, tamanio, logger);
	return bytes_enviados;
}

int enviar_pedido_valor(int socket, char* clave, int id){
	int tamanio = tamanio_buffer_string(clave);
	void* buffer = malloc(tamanio);
	serializar_string(buffer, clave, id);
	int bytes_enviados = enviar(socket, buffer, tamanio, logger);
	return bytes_enviados;
}

int enviar_confirmacion(int socket, int confirmacion, int id){
	void* buffer = malloc(sizeof(int)*2);
	serializar_int(buffer, confirmacion, id);
	int bytes_enviados = enviar(socket, buffer, sizeof(int)*2, logger);
	return bytes_enviados;
}

int recibir_confirmacion(int socket){
	int confirmacion;
	void* buffer = malloc(sizeof(int));
	recibir(socket, buffer, sizeof(int), logger);
	confirmacion = deserializar_id(buffer);
	return confirmacion;
}

char* recibir_pedido_clave(int socket){
	char* clave;
	int tamanio;
	recibir(socket, &tamanio, sizeof(int), logger);
	void* buffer = malloc(tamanio);
	recibir(socket, buffer, tamanio, logger);
	deserializar_string(buffer,clave);
	return clave;
}

status_clave recibir_status(int socket){
	status_clave status;
	int tamanio;
	recibir(socket, &tamanio, sizeof(int), logger);
	void* buffer = malloc(tamanio);
	recibir(socket, buffer, tamanio, logger);
	status = deserializar_status_clave(buffer);
	return status;
}

t_esi_operacion recibir_instruccion(int socket){
	t_esi_operacion instruccion;
	int tamanio;
	void* buffercito = malloc(sizeof(int));
	recibir(socket, buffercito, sizeof(int), logger);
	tamanio = deserializar_id(buffercito);
	void* buffer = malloc(tamanio);
	recibir(socket, buffer, tamanio, logger);
	instruccion = deserializar_instruccion(buffer);
	return instruccion;
}

int enviar_operacion(int socket, t_esi_operacion instruccion){
	int tamanio = tamanio_buffer_instruccion(instruccion);
	void* buffer = malloc(tamanio);
	serializar_instruccion(buffer, instruccion);
	int resultado = enviar(socket, buffer, tamanio, logger);
	return resultado;
}

